<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes' ?>
<?rfc tocdepth='3' ?>
<?rfc sortrefs='yes' ?>
<rfc category="std" docName="draft-mglt-dnsop-dnssec-validator-requirements-06" ipr="trust200902">
  <front>
    <title abbrev="DNSSEC Validator Requirements">DNSSEC Validators Requirements</title>


<author fullname="Daniel Migault" initials="D." surname="Migault">
<organization>Ericsson</organization>
<address>
   <email>daniel.migault@ericsson.com</email>
</address>
</author>


    <author initials="D." surname="York" fullname="Dan York">
<organization>Internet Society</organization>
      <address>
        <email>york@isoc.org</email>
      </address>
    </author>
    <author initials="E." surname="Lewis" fullname="Edward Lewis">
<organization>ICANN</organization>
      <address>
        <email>edward.lewis@icann.org</email>
      </address>
    </author>
    <date />
    <area>INTERNET</area>
    <workgroup>DNSOP</workgroup>
    <abstract>

<t>DNSSEC provides data integrity and source authentication to a basic
DNS RReet. Given a RRset, a public key and a signature, a DNSSEC
validator checks the signature, time constraints, and other, local,
policies. In case of mismatch the RRSet is considered illegitimate and
is rejected.</t>

<t>Accuracy in DNSSEC validation, that is, avoiding false positives and
catching true negatives, requires that both the signing process and
validation process adhere to the protocol, which begins with external
configuration parameters.  This document describes requirements for a
validator to be able to perform accurate validation.  </t>
   
</abstract> 

</front> 

<middle> 

<section title="Requirements notation">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>


 </section> <section title="Introduction">

<t> DNSSEC validation <xref target="RFC4033"/>, <xref target="RFC4034"/>
and <xref target="RFC4035"/> has two core concepts. One is the matching
of a RRSIG resource record's contents to a RRset, making use of a DNSKEY
resource record (named in the RRSIG record).  Two is the placing of
trust in the DNSKEY resource record.  </t>

<t>Evaluation based on a RRSIG record involves a few steps. Most
visible is a cryptographic operation, matching the digital signature in
the RRSIG with the specified public key in the named DNSKEY record and a
properly prepared DNS RRset.  This is meant to demonstrate that the
RRset came from an entity with the private component of the key (source
authenticity).  </t>

<t> Not to be forgotten are the other matches to perform.  To address
the threat of reply attacks, wall-clock (absolute) time is checked.  To
address the authority of the source, the named DNSKEY record is checked
for appropriateness (i.e., owned by the same zone is the default
policy).  </t>

<t> The RRSIG record also contains other information intended to help
the validator perform its work, in some cases "sane value" checks are
performed.  For instance, the original TTL (needed to prepare the RR set
for validation) ought to be equal to or higher than the received TTL.
</t>

<t> Requirements related to validation exist in <xref
target="RFC4033"/>, <xref target="RFC4034"/> and <xref
target="RFC4035"/>. However, the specification of the validation is not
sufficient to enable a wide deployment of DNSSEC validators. In fact,
there are a number of situations where the necessary condition are not
met by the DNSSEC validator to perform DNSSEC validation. When such
conditions are not met, the DNSSEC validation may qualify improperly a
RRset as invalid. This document is focused on the necessary mechanisms
that DNSSEC validators should implement in order to make DNSSEC
validation output accurate. The mechanisms described in this document
include, provisioning mechanisms as well as monitoring and management
mechanisms that enables an administrator to validate the validity of the
DNSSEC validation output.</t>
  
</section>
    

<section title="Terminology">

<t> This document uses the following terminology: </t>

<t><list>

<t>DNSSEC validator: the entity that performs DNSSEC resolution and
performs signature validation.</t> <t>Accurate validation: validation
that avoids false positives and catches true negatives. (not sure if
this is needed, but seems appropriate)</t>

<t>Trust Anchor Data Store: </t>

</list></t>

    </section>

<section anchor="sec-time" title="Time derivation and absence of Real Time Clock">

<t>With M2M communication some devices are not expecting to embed Real
Time Clock (Raspberry Pi is one example of such devices). When these
devices are re-plugged the initial time is set to January 1 1970. Other
devices that have clocks that may suffer from time derivation. All these
devices cannot rely on their time estimation to perform DNSSEC
validation.  </t>

<t><list style="format REQ%d:" counter="my_count">

<t> A DNSSEC validator MUST be provided means to update the time without
relying on DNSSEC.</t>

</list></t>

<t>Note that updating time in order to be able to perform DNSSEC
validation may easily come with a chicken-and-egg problem when the NTP
server is designated by its FQDN. The update mechanisms must consider
the DNSSEC validator may not able to validate the DNSSEC queries. In
other words, the mechanisms may have to update the time over an unsecure
DNSSEC resolution.</t>

    </section>

<section title="Trust Anchor" anchor="sec-trust-anchor" >

<section title="Trust Anchor Bootstrapping">

<t>A validator needs to have trust anchors or it will never be able to
construct a chain of trust. Trust anchors are defined by DNSSEC to be
keys that are inherently trusted, configured by authorized parties, in
the validator.  The configuration can be via an automated process, such
as Automated Updates of DNSSEC Trust Anchors <xref target="RFC5011"/>,
<xref target="I-D.ietf-dnsop-rfc5011-security-considerations"/>, or
via manual process.</t>

<t>An implementation of a validator needs to allow an operator to choose
any automated process supported by the validator.  (No requirements are
stated about what processes to support, only one is standardized to
date.)  An implementation needs to also afford the operator the ability
to override or manage via a purely manual process, the storage of
managed keys.  This includes adding, deleting, changing and
inspecting.</t>

<t>Beyond the scope of these requirements are the decision processes of
authorized parties in placing trust in keys.</t>

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator MUST check the validity of its Trust Anchors. When a
Trust Anchor cannot be verified, the DNSSEC validator MUST send a
warning and SHOULD NOT start validating traffic without manual
validation.</t> 

<t>A DNSSEC validator SHOULD be able to retrieve a Trust Anchor with
bootstrapping mechanism. Such mechanism' security MUST NOT be based on
DNSSEC, but could instead include downloading a XML file
from a trusted URL, or a PKIX certificate.</t>
        
</list></t>

<!--
<t>Editor-to-editor: I'm undecided on the following.  As much as the 
first order requirements are for operators to "edit" the trust anchor
store, including requirements for "bootstrapping" might be a good
idea.  I'd strike referring to implementations though, as anything
done today meets operating realities that may change underneath us
in the future.</t>
-->

<t>Although some bootstrapping mechanisms to securely retrieve publish
<xref target="RFC7958"/> and retrieve <xref target="UNBOUND-ANCHOR"/>
the Root Zone Trust Anchor have been defined, it is believed these
mechanisms should be extended to other KSKs or Trust Anchors. In fact it
is not always possible to build a trusted delegation between the Root
Zone and any sub zone. This may happen for example if one of the upper
zones does not handle the secure delegation or improperly implement it.
A DS RRset may not be properly filled or its associated signature cannot
be validated. As the chain of trust between a zone and the root zone may
not be validated, the DNSSEC validation for the zone requires a Trust
Anchor. Such DNS(SEC) resolutions may be critical for infrastructure
management. A company "Example" may, for example, address all its
devices under the domain example.com and may not want disruption to
happen if the .com delegation cannot be validated for any reason. Such
companies may provision there DNSSEC validator with the Trust Anchor KSK
for the zone example.com in addition to the regular DNSSEC delegation.
Similarly some some domains may present different views such as a
"private" view and a "public view". These zones may have some different
content, and may use a different KSK for each view.</t>

</section>

<section title="Trust Anchor Data Store">

<t>When DNSSEC validator are running and a Trust Anchor KSK roll over is
ongoing, a network administrator or any trust party may be willing to
check whether the new published keys are being stored in a Trust Anchor
Data Store with an appropriated status. Such inspection aims at
detecting an non successful Trust Anchor roll over before traffic
is being rejected. When a new Trust Anchor has not been considered by
the DNSSEC validator, a trusted party may be able to provision the
DNSSEC validator with the new Trust Anchor, and eventually may remove the
revoked Trust Anchor.</t>  

<t>While using a Trust Anchor that has been removed results in the
DNSSEC validator rejecting multiple legitimate responses, the
consequences associated to accepting a rogue Trust Anchor as a
legitimate Trust Anchor are even worst. Such attacks would result in an
attacker taking control of the entire naming space behind the Trust
Anchor. In the case of the Root Zone KSK, for example, almost all name
space would be under the control of the attacker. In addition, to the
name space, once the rogue Trust Anchor is configured, there is little
hope the DNSSEC validator be re-configured with the legitimate Trust
Anchor without manual intervention. As a result, it is crucial to
cautiously handle operations related to the Trust Anchor provisioning.
Means must be provided so network administrator can clearly diagnose the
reason a Trust Anchor is not valid to avoid accepting a rogue Trust
Anchor inadvertently.</t>

<t>DNSSEC may also be used in some private environment. Corporate
networks and home networks, for example, may want to take advantage of
DNSSEC for a local scope network. Typically, a corporate network may use
a local scope Trust Anchor to validate DNS RRsets provided by authoritative
DNSSEC server in the corporate network. This use case is also known as
the "split-view" use case. These RRsets within the corporate network may
differ from those hosted on the public DNS infrastructure. Note that
using different Trust Anchor for a given zone may expose a zone to signature
invalidation. This is especially the case for DNSSEC validators that are
expected to flip-flop between local and public scope. How validators
have to handle the various provisioned Trust Anchors is out of scope of the
document.  </t>
      
<t> Home network may use DNSSEC with TLDs or associated domain names
that are of local scope and not even registered in the public DNS
infrastructure.  This requires the ability to manage the Trust Anchor as
well.</t>

<t>The necessity to interact with the Trust Anchors lead to the
following requirements:</t>

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator MUST store its Trust Anchors in a dedicated Trust
Anchor Data Store. Such database MUST store informations associated to
each Trust Anchor status as well as the time the status has been noticed
by the DNSSEC validator. Such database MUST be resilient to DNSSEC
validator reboot.</t>

<t>Trust Anchor states SHOULD at least consider those
described in <xref target="RFC5011"/> (Start, AddPend, Valid, Missing,
Revoked, Removed). Additional states SHOULD also be able to indicate
additional motivations for revoking the Trust Anchor such as a Trust
Anchor known to be corrupted, a Trust anchor miss published, or part of
a regular roll over procedure.</t>    

<t>A DNSSEC validator MUST provide access to the Trust Anchor Data Sase
to authorized user only. Access control is expected to be based on a
least privileged principles.</t>  

<t>A trusted party MUST be able to add, remove a Trust Anchor in the
Trust Anchor Data Store.</t>

</list></t>

</section>

<section title="Interactions with the cached RRsets">

<t>In addition when a Trust Anchor is revoked, the DNSSEC
validator may behave differently if the revocation is motivated by a
regular roll over operation or instead by revoking a Trust Anchor that
is known as being corrupted. In the case the roll over procedure, is
motivated by revoking a Trust Anchor  that is known to be corrupted, the
DNSSEC validator may be willing to flush all RRsets that depends on the
Trust Anchor. </t>     

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator MUST be able to flush the cached RRsets that rely
on a Trust Anchor.</t>

</list></t>

</section>

</section>

<section anchor="sec-ksk-zsk" title="ZSK / KSK">


<section title="KSK/ZSK Data Store">

<t>A number of reasons may result in inconsistencies between the RRsets
stored in the cache and those published by the authoritative server.</t>

<t>An emergency KSK / ZSK rollover may result in a new KSK / ZSK with
associated new RRSIG published in the authoritative zone, while DNSSEC
validator may still cache the old value of the ZSK / KSK.  For a RRset
not cached, the DNSSEC validator performs a DNSSEC query to the
authoritative server that returns the RRset signed with the new KSK /
ZSK. The DNSSEC validator may not be able to retrieve the new KSK / ZSK
while being unable to validate the signature with the old KSK / ZSK.
This either result in a bogus resolution or in an invalid signature
check. Note that by comparing the Key Tag Fields, the DNSSEC validator
is able to notice the new KSK / ZSK used for signing differs from the
one used to generate the received generated signature. However, the
DNSSEC validator is not expectected to retrieve the new ZSK / KSK, as
such behavior could be used by an attacker. Intsead, ZSK / ZSK key roll
ove rprocedure are expected to avoid such inconsistencies.</t>

<t>Similarly, a KSK / ZSK roll over may be performed normally, that is
as described in <xref target="RFC6781"/> and <xref target="RFC7583"/>.
While the KSK / ZSK roll over is performed, there is no obligation to
flush the RRsets in the cache that have been associated with the old
key. In fact, these RRset may still be considered as trusted and be
removed from the cache as their TTL timeout. With very long TTL, these
RRset may remain in the cache while the ZSK / KSK with a shorter TTL is
no longer published nor in the cache. In such situations, the purpose of
the KSK / ZSK is to validate the data is considered trusted at the time
it enters the cache, and such trust may remain after the KSK / ZSK is
being rolled over. Note also that even though the data may not be
associated to the KSK / ZSK that has been used to valiadte the data, the
link between the KSK / ZSK and teh data is still stored in teh cache
using the RRSIG. Note also that inconsistencies between the ZSK / KSK
stored in the cache and those published on the authoritative server, may
lead to inconsistencies to downstream DNSSEC validators that realy on
multiple cache over time. Typically, a request for the KSK / ZSK may
have been provided by a cache that is storing the new published value,
while the data and associated sigature may be associated to the old KSK
/ ZSK.</t>

<t>KSK and ZSK are associated with configuration parameters, and as such
are expected to be stored only in the cache. As a result, flushing their
value from the cache could constitute a way forward to refresh them. On
the other hand, their respective function is also to prevent
illegitimate RRsets to be validated and so more understanding is need
before taking any action associated to the KSK or ZSK. More
specifically, the network administrator SHOULD be provided the
appropriated information required to distinguish a misconfiguration from
an attack.</t>  

<t>The following requirements are thus considered for the KSK / ZSK.</t>

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator MUST store its KSK/ZSK in a dedicated KSK/ZSK Data
Base. Such database MUST store informations associated to each KSK/ZSK
status as well as the time the status has been noticed by the DNSSEC
validator. Such database MUST NOT be resilient to DNSSEC validator
reboot, that is the information stored in the Data Base MUST NOT be used
to populate the cache, while it MAY be used as second factor
verification, or audit for example.</t>

<t>KSK/ZSK status and informaton SHOULD be monitored continuously and
associated with their respective state as well as verified time. These
states and time SHOULD be resilient to reboot.</t>

<t>KSK/ZSK states SHOULD at least consider those described in section
3.1 of <xref target="RFC7583"/> (Generated, Published, Ready, Active,
Retired, Dead, Removed, Revoked ). Additional states SHOULD also be able
to indicate additional motivations for revoking the KSK/ZSK such as a
KSK/ZSK known to be corrupted, a KSK/ZSK miss published, or part of a
regular roll over procedure.</t>    

<t>A DNSSEC validator MUST provide access to the KSK/ZSK data base
to authorized user only. Access control is expected to be based on a
least privileged principles.</t>  

<t>A trusted party MUST be able to add, remove a Trust Anchor in the
KSK/ZSK Database.</t>
            
</list></t>
 
<t>Similarly to its counter part the TA Data Store, the KSK/ZSK Data
Store is expected to be resilient to reboot. However the motivation for
having the KSK/ZSK Data Store resilient to reboot differs from those for
making the TA Data Store resilient to reboot. TA Data Store needs to be
resilient as the Trust Anchors are necessary to perform the DNSSEC
validation.  KSK/ZSK are not expected to be locally stored, but instead
are expected to be resolved, validated by the TA and stored in the
cache. The reason for making the KSK/ZSK Data Store resilient to reboot
is mostly to enable audit of the DNSSEC validator.</t>
   
</section>

<section title="KSK/ZSK Data Store and Trust Anchor Data Store">

<t>A zone may have been badly signed, which means that the KSK or ZSK
cannot validate the RRSIG associated to the RRsets. This may not be due
to a key roll over, but to an incompatibility between the keys (KSK or
ZSK) and the signatures.  </t>

<t>When such situation occurs, there is only a choice between not
validating the RRsets or invalidating their signature. This is a policy
design that needs to be taken by the network administrator. In other
ways, flushing the RRset are not expected to address this issue. Such
KSK/ZSK are known as Negative Trust Anchors <xref target="RFC7646"/>.
</t>
          
      
<t>With Negative Trust Anchor, the zone for a given time will be known
as "known insecure". The DNSSEC Validator is not expected to perform
signature validation for this zone. It is expected that this information
is associated to a Time To Live (TTL).</t>
      
<t>Note that, this information may be used as an attack vector to
impersonate a zone, and must be provided in a trusted way, by a trusted
party.</t>
      
<t>If a zone has been badly signed, the administrator of the
authoritative DNS server may resign the zone with the same keys or
proceed to an emergency key rollover. If the signature is performed with
the same keys, the DNSSEC Validator may notice by itself that RRSIG can
be validated. On the other hand if a key rollover is performed, the
newly received RRSIG will carry a new key id. Upon receiving a new key
id in the RRSIG, the DNSSEC Validator is expected to retrieve the new
ZSK/KSK.  If the RRSIG can be validated, the DNSSEC Validator is
expected to remove the "known insecure" flag.  </t>
      
<t> However, if the KSK/ZSK are rolled over and RRSIG cannot be
validated, it remains hard for the DNSSEC validator to determine whether
the RRSIG cannot be validated or that RRSIG are invalid. As a result:
</t>
      
<t><list style="format REQ%d:" counter="my_count">

<t>A trusted party MUST be able to indicate a DNSSEC validator that a
KSK or a ZSK as Negative Trust Anchor. Such Trust Anchors MUST NOT be
used for RRSIG validation and MUST be moved to the Trust Anchor
Data Store, so the information become resilient to reboot.</t>

<t> A trusted party MUST be able to indicate a DNSSEC validator  that a
KSK/ZSK is known "back to secure".</t>

</list></t>
    
      
</section>

<section title="Interactions with cached RRsets">

<t>In order to refresh a KSK/ZSK, a trusted third party may simply flush
the corresponding KSK/ZSK from the cache.</t>

<t>In order to avoid inconsistency between KSK/ZSK and cached RRsets, a
trusted third party may willing to remove all cached RRsets that have
been validated by the KSK/ZSK upon some specific states (revoked, or
Removed for example), of after some time after the state is noticed. In
this later case, only the RRset whose TTL has not expired yet would be
flushed. </t>

<t>Finally, when a KSK/ZSK is known to be corrupted, the DNSSEC
validator may removed all cached RRsets associated to the KSK/ZSK.</t>

<t>As a result, the following requirements are expected: </t>

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator MUST be able to flush the cached KSK/ZSK.</t>

<t>A DNSSEC validator MUST be able to flush the cached RRsets associated
to a KSK/ZSK.</t>

</list></t>
 

</section>

</section>

      
<section anchor="sec-invalid-ds" title="DS">
        
<t>The DS RRset is stored in the parent zone to build a chain of trust
with the child zone. This DS RRset can be invalid because its RDATA
(KSK) is not anymore used in the child zone or because the DS is badly
signed and cannot be validated by the DNSSEC Validator.</t>
        
<t>In both cases the child zone is considered as bogus and the valid
child zone's KSK should become a Trust Anchor KSK. This
requirements is fulfilled by the requirement to add a Trust Anchor in
<xref target="sec-trust-anchor"/>.  </t>

      
</section>

<section title="Cryptography Deprecation">

<t>As mentioned in <xref target="I-D.ietf-ipsecme-rfc4307bis"/> and
<xref target="I-D.ietf-ipsecme-rfc7321bis"/> cryptography used one day is
expected over the time to be replaced by new and more robust
cryptographic mechanisms. In the case of DNSSEC signature protocols are
likely to be updated over time. In order to anticipate the sunset of one
of the signature scheme, a DNSSEC validator may willing to estimate the
impact of deprecating one signature scheme.</t>

<t>Currently  <xref target="RFC6975"/> provides the ability for a DNSSEC
validator to announce an authoritative server the supported signature
schemes. However, a DNSSEC validator is not able to determine other than
by trying whether a signature scheme is supported by the authoritative
server.</t>

<t>In order for a DNSSEC validator to safely deprecate one signature
scheme the following requirement should be fulfilled.</t>  

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validator SHOULD be able to request the signature
scheme  supported by an authoritative server.</t>

</list></t>

</section>


<section title="Reporting">

<t>A DNSSEC validator receiving a DNS response cannot make the
difference between receiving an non-secure response versus an attack.
Dropping DNSSEC fields by a misconfigured middle boxes, such as DS,
RRRSIG is considered as an attack.</t>

<t>A DNSSEC validator is expected to perform secure DNS resolution and
as such protect its stub client. An invalid response may be the result
of an attack or a misconfiguration, and the DNSSEC validator may play
an important role in sharing this information.</t> 

<t><list style="format REQ%d:" counter="my_count">

<t>A DNSSEC validation SHOULD be able to report the unavailability of
the DNSSEC service.</t>

<t>A DNSSEC validator SHOULD be able to report a invalid DNSSEC
validation.</t>

</list></t>


</section>

<section title="IANA Considerations">
      
<t> There are no IANA consideration for this document.  </t>
    
</section>
    

<section anchor="sec-considerations" title="Security Considerations">
      
<t> The requirements listed in this document aim at providing the DNSSEC
validator appropriated information so DNSSEC validation can be
performed. On the other hand, providing inappropriate information can
lead to misconfiguring the DNSSEC validator, and thus disrupting the
DNSSEC resolution service. As a result, enabling the setting of
configuration parameters by a third party may open a wide surface of
attacks.  </t>
      
<t> As an appropriate time value is necessary to perform signature check
(cf. <xref target="sec-time"/>), an attacker may provide rogue time
value to prevent the DNSSEC validator to check signatures.  </t>
      
<t> An attacker may also affect the resolution service by regularly
asking the DNSSEC validator to flush the KSK/ZSK from its cache (cf.
<xref target="sec-ksk-zsk"/>). All associated data will also
be flushed. This generates additional DNSSEC resolution and additional
validations, as RRSet that were cached require a DNSSEC resolution over
the Internet. This affects the resolution service by slowing down
responses, and increases the load on the DNSSEC validator.  </t>
      
<t> An attacker may ask the DNSSEC validator to consider a rogue KSK/ZSK
( cf. Invalid DS in <xref target="sec-invalid-ds"/> or  Private KSK in
<xref target="sec-trust-anchor"/>), thus hijacking the DNS zone.
Similarly, (cf. <xref target="sec-ksk-zsk"/>) an attacker may inform the
DNSSEC validator not to trust a given KSK in order to prevent DNSSEC
validation to be performed.  </t>
      
<t> An attacker (cf. <xref target="sec-ksk-zsk"/>)  can advertise a
"known insecure" KSK or ZSK is "back to secure" to prevent signature
check to be performed correctly.  </t>
      
<t> As a result, information considered by the DNSSEC validator should
be from a trusted party. This trust party should have been
authenticated, and the channel used to exchange the information should
also be protected and authenticated.  </t>
    
</section>
    

<section title="Acknowledgment">
      
<t>The need to address DNSSEC issues on the resolver side started in the
Home Networks mailing list and during the IETF87 in Berlin. Among
others, people involved in the discussion were Ted Lemon, Ralph Weber,
Normen Kowalewski, and Mikael Abrahamsson. People involved in the email
discussion initiated by Jim Gettys were, with among others, Paul
Wouters, Joe Abley and Michael Richardson.
</t>
      
<t> The current document has been initiated after a discussion with Paul
Wouter and Evan Hunt.</t>
    
</section>
  </middle>
  <back>
    <references title="Normative References">

<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.4033.xml"?>
<?rfc include="reference.RFC.4034.xml"?>
<?rfc include="reference.RFC.4035.xml"?>
<?rfc include="reference.RFC.5011.xml"?>
<?rfc include="reference.RFC.6975.xml"?>

    </references>

    <references title="Informational References">

<reference anchor="UNBOUND-ANCHOR" target="https://www.unbound.net/documentation/doxygen/unbound-anchor_8c.html#details">
  <front>
    <title>unbound-anchor.c File Reference</title>
    <author/>
    <date/>
  </front>
</reference>

<?rfc include="reference.RFC.6781.xml"?>
<?rfc include="reference.RFC.7958.xml"?>
<?rfc include="reference.RFC.7583.xml"?>
<?rfc include="reference.RFC.7646.xml"?>
<?rfc include="reference.I-D.ietf-dnsop-rfc5011-security-considerations.xml"?>
<?rfc include="reference.I-D.ietf-ipsecme-rfc4307bis.xml"?>
<?rfc include="reference.I-D.ietf-ipsecme-rfc7321bis.xml"?>
    </references>
  </back>
</rfc>
